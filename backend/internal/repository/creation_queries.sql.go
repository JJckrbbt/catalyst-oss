// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: creation_queries.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const createIngestionJob = `-- name: CreateIngestionJob :one
INSERT INTO ingestion_jobs (
	id, 
	source_type,
	source_details,
	report_type,
	status, 
	user_id,
	source_uri
) VALUES (
	$1, $2, $3, $4, $5, $6, $7
)
RETURNING id, source_type, source_details, report_type, status, started_at, completed_at, error_details, user_id, source_uri, rows_upserted, rows_triaged
`

type CreateIngestionJobParams struct {
	ID            pgtype.UUID `json:"id"`
	SourceType    string      `json:"source_type"`
	SourceDetails []byte      `json:"source_details"`
	ReportType    string      `json:"report_type"`
	Status        string      `json:"status"`
	UserID        pgtype.Int8 `json:"user_id"`
	SourceUri     pgtype.Text `json:"source_uri"`
}

// Inserts a new file ingestion job record.
func (q *Queries) CreateIngestionJob(ctx context.Context, arg CreateIngestionJobParams) (IngestionJob, error) {
	row := q.db.QueryRow(ctx, createIngestionJob,
		arg.ID,
		arg.SourceType,
		arg.SourceDetails,
		arg.ReportType,
		arg.Status,
		arg.UserID,
		arg.SourceUri,
	)
	var i IngestionJob
	err := row.Scan(
		&i.ID,
		&i.SourceType,
		&i.SourceDetails,
		&i.ReportType,
		&i.Status,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ErrorDetails,
		&i.UserID,
		&i.SourceUri,
		&i.RowsUpserted,
		&i.RowsTriaged,
	)
	return i, err
}

const createItem = `-- name: CreateItem :one
INSERT INTO items (
	item_type, 
	scope,
	business_key,
	status,
	custom_properties,
	embedding
) VALUES (
	$1, $2, $3, $4, $5, $6
)
RETURNING id, item_type, scope, business_key, status, custom_properties, embedding, created_at, updated_at
`

type CreateItemParams struct {
	ItemType         ItemType        `json:"item_type"`
	Scope            pgtype.Text     `json:"scope"`
	BusinessKey      pgtype.Text     `json:"business_key"`
	Status           ItemStatus      `json:"status"`
	CustomProperties []byte          `json:"custom_properties"`
	Embedding        pgvector.Vector `json:"embedding"`
}

// Inserts a new item record into database
// Go is responsible for constructing the custom_properties JSONB
func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) (Item, error) {
	row := q.db.QueryRow(ctx, createItem,
		arg.ItemType,
		arg.Scope,
		arg.BusinessKey,
		arg.Status,
		arg.CustomProperties,
		arg.Embedding,
	)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.ItemType,
		&i.Scope,
		&i.BusinessKey,
		&i.Status,
		&i.CustomProperties,
		&i.Embedding,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTempItemsStagingTable = `-- name: CreateTempItemsStagingTable :exec
CREATE TEMP TABLE temp_items_staging (LIKE items INCLUDING DEFAULTS) ON COMMIT DROP
`

// Creates a temporary table for staging items during ingest
// This table is dropped on commit
func (q *Queries) CreateTempItemsStagingTable(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempItemsStagingTable)
	return err
}

const createUserFromAuthProvider = `-- name: CreateUserFromAuthProvider :one
INSERT INTO "users" (
	auth_provider_subject,
	email,
	display_name,
	is_active,
	is_admin
) VALUES (
	$1, $2, $3, TRUE, FALSE
)
RETURNING id, auth_provider_subject, email, display_name, is_active, is_admin, updated_at, created_at
`

type CreateUserFromAuthProviderParams struct {
	AuthProviderSubject string      `json:"auth_provider_subject"`
	Email               string      `json:"email"`
	DisplayName         pgtype.Text `json:"display_name"`
}

// Creates a new user record from the authentication provider's details
func (q *Queries) CreateUserFromAuthProvider(ctx context.Context, arg CreateUserFromAuthProviderParams) (User, error) {
	row := q.db.QueryRow(ctx, createUserFromAuthProvider, arg.AuthProviderSubject, arg.Email, arg.DisplayName)
	var i User
	err := row.Scan(
		&i.ID,
		&i.AuthProviderSubject,
		&i.Email,
		&i.DisplayName,
		&i.IsActive,
		&i.IsAdmin,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
