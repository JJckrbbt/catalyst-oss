// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: ingestion_queries.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createIngestionError = `-- name: CreateIngestionError :one
INSERT INTO ingestion_errors (
    id,
    job_id,
    original_row_data,
    reason_for_failure
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, job_id, timestamp, original_row_data, reason_for_failure
`

type CreateIngestionErrorParams struct {
	ID               pgtype.UUID `json:"id"`
	JobID            pgtype.UUID `json:"job_id"`
	OriginalRowData  []byte      `json:"original_row_data"`
	ReasonForFailure string      `json:"reason_for_failure"`
}

// Inserts a new ingestion error record for a row that failed processing.
func (q *Queries) CreateIngestionError(ctx context.Context, arg CreateIngestionErrorParams) (IngestionError, error) {
	row := q.db.QueryRow(ctx, createIngestionError,
		arg.ID,
		arg.JobID,
		arg.OriginalRowData,
		arg.ReasonForFailure,
	)
	var i IngestionError
	err := row.Scan(
		&i.ID,
		&i.JobID,
		&i.Timestamp,
		&i.OriginalRowData,
		&i.ReasonForFailure,
	)
	return i, err
}

const itemExistsByBusinessKey = `-- name: ItemExistsByBusinessKey :one
SELECT EXISTS(SELECT 1 FROM items WHERE item_type = $1 AND business_key = $2)::int
`

type ItemExistsByBusinessKeyParams struct {
	ItemType    ItemType    `json:"item_type"`
	BusinessKey pgtype.Text `json:"business_key"`
}

// Checks for the existence of an item by its type and business key. Returns 1 if it exists, 0 otherwise.
func (q *Queries) ItemExistsByBusinessKey(ctx context.Context, arg ItemExistsByBusinessKeyParams) (int32, error) {
	row := q.db.QueryRow(ctx, itemExistsByBusinessKey, arg.ItemType, arg.BusinessKey)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}
