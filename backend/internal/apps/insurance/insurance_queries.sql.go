// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: insurance_queries.sql

package insurance

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getPolicyholderByID = `-- name: GetPolicyholderByID :one
SELECT id, item_type, policyholder_id, state, status, created_at, updated_at, policyholder_name, city, customer_since_date, customer_level, active_policies
FROM vw_policyholders
WHERE policyholder_id = $1
`

// Fetches a single policyholder by their unique PolicyHolder_ID.
func (q *Queries) GetPolicyholderByID(ctx context.Context, policyholderID pgtype.Text) (VwPolicyholder, error) {
	row := q.db.QueryRow(ctx, getPolicyholderByID, policyholderID)
	var i VwPolicyholder
	err := row.Scan(
		&i.ID,
		&i.ItemType,
		&i.PolicyholderID,
		&i.State,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PolicyholderName,
		&i.City,
		&i.CustomerSinceDate,
		&i.CustomerLevel,
		&i.ActivePolicies,
	)
	return i, err
}

const listClaims = `-- name: ListClaims :many

SELECT id, item_type, claim_id, policy_number, system_status, embedding, created_at, updated_at, policyholder_id, claim_type, date_of_loss, description_of_loss, claim_amount, business_status, adjuster_assigned
FROM vw_insurance_claims
WHERE
    adjuster_assigned = COALESCE($3, adjuster_assigned)
AND
    business_status = COALESCE($4, business_status)
AND
    policy_number = COALESCE($5, policy_number)
ORDER BY
    date_of_loss DESC
LIMIT $1
OFFSET $2
`

type ListClaimsParams struct {
	Limit            int32       `json:"limit"`
	Offset           int32       `json:"offset"`
	AdjusterAssigned pgtype.Text `json:"adjuster_assigned"`
	Status           pgtype.Text `json:"status"`
	PolicyNumber     pgtype.Text `json:"policy_number"`
}

// backend/sql/apps/insurance/queries/insurance_queries.sql
// Fetches a paginated and filtered list of insurance claims.
func (q *Queries) ListClaims(ctx context.Context, arg ListClaimsParams) ([]VwInsuranceClaim, error) {
	rows, err := q.db.Query(ctx, listClaims,
		arg.Limit,
		arg.Offset,
		arg.AdjusterAssigned,
		arg.Status,
		arg.PolicyNumber,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VwInsuranceClaim
	for rows.Next() {
		var i VwInsuranceClaim
		if err := rows.Scan(
			&i.ID,
			&i.ItemType,
			&i.ClaimID,
			&i.PolicyNumber,
			&i.SystemStatus,
			&i.Embedding,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PolicyholderID,
			&i.ClaimType,
			&i.DateOfLoss,
			&i.DescriptionOfLoss,
			&i.ClaimAmount,
			&i.BusinessStatus,
			&i.AdjusterAssigned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPolicyholders = `-- name: ListPolicyholders :many
SELECT id, item_type, policyholder_id, state, status, created_at, updated_at, policyholder_name, city, customer_since_date, customer_level, active_policies
FROM vw_policyholders
WHERE
    state = COALESCE($3, state)
AND
    customer_level = COALESCE($4, customer_level)
ORDER BY
    policyholder_name
LIMIT $1
OFFSET $2
`

type ListPolicyholdersParams struct {
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
	State         pgtype.Text `json:"state"`
	CustomerLevel pgtype.Text `json:"customer_level"`
}

// Fetches a paginated and filtered list of policyholders.
func (q *Queries) ListPolicyholders(ctx context.Context, arg ListPolicyholdersParams) ([]VwPolicyholder, error) {
	rows, err := q.db.Query(ctx, listPolicyholders,
		arg.Limit,
		arg.Offset,
		arg.State,
		arg.CustomerLevel,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VwPolicyholder
	for rows.Next() {
		var i VwPolicyholder
		if err := rows.Scan(
			&i.ID,
			&i.ItemType,
			&i.PolicyholderID,
			&i.State,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PolicyholderName,
			&i.City,
			&i.CustomerSinceDate,
			&i.CustomerLevel,
			&i.ActivePolicies,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
