// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: insurance_queries.sql

package insurance

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getPolicyholderBYID = `-- name: GetPolicyholderBYID :one
SELECT id, item_type, policyholder_id, state, status, created_at, updated_at, policyholder_name, city, customer_since_date, customer_level, active_policies
FROM vw_policyholders
WHERE policyholder_id = $1
`

func (q *Queries) GetPolicyholderBYID(ctx context.Context, policyholderID pgtype.Text) (VwPolicyholder, error) {
	row := q.db.QueryRow(ctx, getPolicyholderBYID, policyholderID)
	var i VwPolicyholder
	err := row.Scan(
		&i.ID,
		&i.ItemType,
		&i.PolicyholderID,
		&i.State,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PolicyholderName,
		&i.City,
		&i.CustomerSinceDate,
		&i.CustomerLevel,
		&i.ActivePolicies,
	)
	return i, err
}

const listClaims = `-- name: ListClaims :many

SELECT id, item_type, claim_id, policy_number, status, embedding, created_at, updated_at, policyholder_id, claim_type, date_of_loss, description_of_loss, claim_amount, adjuster_assigned
FROM vw_insurance_claims
WHERE
	($3::TEXT IS NULL OR adjuster_assigned = $3)
AND
	($4::TEXT IS NULL OR status = $4)
AND
	($5::TEXT IS NULL OR policy_number = $5)
ORDER BY
	date_of_loss DESC
LIMIT $1
OFFSET $2
`

type ListClaimsParams struct {
	Limit            int32  `json:"limit"`
	Offset           int32  `json:"offset"`
	AdjusterAssigned string `json:"adjuster_assigned"`
	Status           string `json:"status"`
	PolicyNumber     string `json:"policy_number"`
}

// backend/sql/apps/insurance/queries/insurance_queries.sql
func (q *Queries) ListClaims(ctx context.Context, arg ListClaimsParams) ([]VwInsuranceClaim, error) {
	rows, err := q.db.Query(ctx, listClaims,
		arg.Limit,
		arg.Offset,
		arg.AdjusterAssigned,
		arg.Status,
		arg.PolicyNumber,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VwInsuranceClaim
	for rows.Next() {
		var i VwInsuranceClaim
		if err := rows.Scan(
			&i.ID,
			&i.ItemType,
			&i.ClaimID,
			&i.PolicyNumber,
			&i.Status,
			&i.Embedding,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PolicyholderID,
			&i.ClaimType,
			&i.DateOfLoss,
			&i.DescriptionOfLoss,
			&i.ClaimAmount,
			&i.AdjusterAssigned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPolicyholders = `-- name: ListPolicyholders :many
SELECT id, item_type, policyholder_id, state, status, created_at, updated_at, policyholder_name, city, customer_since_date, customer_level, active_policies
FROM vw_policyholders
WHERE
	($3::TEXT IS NULL OR state = $3)
AND
	($4::TEXT IS NULL OR customer_level = $4)
ORDER BY
	policyholder_name
LIMIT $1
OFFSET $2
`

type ListPolicyholdersParams struct {
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
	State         string `json:"state"`
	CustomerLevel string `json:"customer_level"`
}

func (q *Queries) ListPolicyholders(ctx context.Context, arg ListPolicyholdersParams) ([]VwPolicyholder, error) {
	rows, err := q.db.Query(ctx, listPolicyholders,
		arg.Limit,
		arg.Offset,
		arg.State,
		arg.CustomerLevel,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VwPolicyholder
	for rows.Next() {
		var i VwPolicyholder
		if err := rows.Scan(
			&i.ID,
			&i.ItemType,
			&i.PolicyholderID,
			&i.State,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PolicyholderName,
			&i.City,
			&i.CustomerSinceDate,
			&i.CustomerLevel,
			&i.ActivePolicies,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
