// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: insurance_queries.sql

package insurance

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const getClaimDetails = `-- name: GetClaimDetails :one
SELECT
    c.id,
    c.item_type,
    c.claim_id,
    c.policy_number,
    c.system_status,
    c.created_at,
    c.updated_at,
    c.policyholder_id,
    c.claim_type,
    c.date_of_loss,
    c.description_of_loss,
    c.claim_amount,
    c.business_status,
    c.adjuster_assigned,
    p.policyholder_name,
    p.city,
    p.state,
    p.customer_since_date,
    p.customer_level
FROM
    vw_insurance_claims c
JOIN
    vw_policyholders p ON c.policyholder_id = p.policyholder_id
WHERE
    c.id = $1
`

type GetClaimDetailsRow struct {
	ID                int64              `json:"id"`
	ItemType          ItemType           `json:"item_type"`
	ClaimID           pgtype.Text        `json:"claim_id"`
	PolicyNumber      pgtype.Text        `json:"policy_number"`
	SystemStatus      ItemStatus         `json:"system_status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	PolicyholderID    string             `json:"policyholder_id"`
	ClaimType         string             `json:"claim_type"`
	DateOfLoss        pgtype.Date        `json:"date_of_loss"`
	DescriptionOfLoss string             `json:"description_of_loss"`
	ClaimAmount       pgtype.Numeric     `json:"claim_amount"`
	BusinessStatus    string             `json:"business_status"`
	AdjusterAssigned  string             `json:"adjuster_assigned"`
	PolicyholderName  string             `json:"policyholder_name"`
	City              string             `json:"city"`
	State             pgtype.Text        `json:"state"`
	CustomerSinceDate pgtype.Date        `json:"customer_since_date"`
	CustomerLevel     string             `json:"customer_level"`
}

// Fetches a single claim joined with its correspondng policyholder data
func (q *Queries) GetClaimDetails(ctx context.Context, id int64) (GetClaimDetailsRow, error) {
	row := q.db.QueryRow(ctx, getClaimDetails, id)
	var i GetClaimDetailsRow
	err := row.Scan(
		&i.ID,
		&i.ItemType,
		&i.ClaimID,
		&i.PolicyNumber,
		&i.SystemStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PolicyholderID,
		&i.ClaimType,
		&i.DateOfLoss,
		&i.DescriptionOfLoss,
		&i.ClaimAmount,
		&i.BusinessStatus,
		&i.AdjusterAssigned,
		&i.PolicyholderName,
		&i.City,
		&i.State,
		&i.CustomerSinceDate,
		&i.CustomerLevel,
	)
	return i, err
}

const getClaimStatusHistory = `-- name: GetClaimStatusHistory :many
SELECT
    ie.id AS event_id,
    ie.created_at AS event_timestamp,
    ie.event_data, 
    u.display_name AS user_name
FROM
    items_events ie
JOIN
    users u ON ie.created_by = u.id
WHERE
    ie.item_id = $1
AND
    ie.event_type = 'CLAIM_STATUS_CHANGED'
ORDER BY
    ie.created_at DESC
`

type GetClaimStatusHistoryRow struct {
	EventID        int64              `json:"event_id"`
	EventTimestamp pgtype.Timestamptz `json:"event_timestamp"`
	EventData      []byte             `json:"event_data"`
	UserName       pgtype.Text        `json:"user_name"`
}

// Fetches the business status change history for a specific claim item
func (q *Queries) GetClaimStatusHistory(ctx context.Context, itemID int64) ([]GetClaimStatusHistoryRow, error) {
	rows, err := q.db.Query(ctx, getClaimStatusHistory, itemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClaimStatusHistoryRow
	for rows.Next() {
		var i GetClaimStatusHistoryRow
		if err := rows.Scan(
			&i.EventID,
			&i.EventTimestamp,
			&i.EventData,
			&i.UserName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPolicyholderByID = `-- name: GetPolicyholderByID :one
SELECT id, item_type, policyholder_id, state, status, created_at, updated_at, policyholder_name, city, customer_since_date, customer_level, active_policies
FROM vw_policyholders
WHERE policyholder_id = $1
`

// Fetches a single policyholder by their unique PolicyHolder_ID.
func (q *Queries) GetPolicyholderByID(ctx context.Context, policyholderID pgtype.Text) (VwPolicyholder, error) {
	row := q.db.QueryRow(ctx, getPolicyholderByID, policyholderID)
	var i VwPolicyholder
	err := row.Scan(
		&i.ID,
		&i.ItemType,
		&i.PolicyholderID,
		&i.State,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PolicyholderName,
		&i.City,
		&i.CustomerSinceDate,
		&i.CustomerLevel,
		&i.ActivePolicies,
	)
	return i, err
}

const listClaims = `-- name: ListClaims :many

SELECT 
    id,
    item_type,
    claim_id,
    policy_number,
    system_status,
    created_at,
    updated_at,
    policyholder_id,
    claim_type,
    date_of_loss,
    description_of_loss,
    claim_amount,
    business_status,
    adjuster_assigned,
    embedding <=> $3::vector AS similarity_score
FROM vw_insurance_claims
WHERE
    adjuster_assigned = COALESCE($4, adjuster_assigned)
AND
    business_status = COALESCE($5, business_status)
AND
    policy_number = COALESCE($6, policy_number)
AND
    (vector_dims($3::vector) IS NULL OR (embedding <=> $3::vector) < 0.8)
ORDER BY
    similarity_score ASC,
    CASE WHEN $7::text = 'claim_amount' AND $8::text = 'asc' THEN claim_amount END ASC,
    CASE WHEN $7::text = 'claim_amount' AND $8::text = 'desc' THEN claim_amount END DESC,
    CASE WHEN $7::text = 'date_of_loss' AND $8::text = 'asc' THEN date_of_loss END ASC,
    CASE WHEN $7::text = 'date_of_loss' AND $8::text = 'desc' THEN date_of_loss END DESC,
    date_of_loss DESC
LIMIT $1
OFFSET $2
`

type ListClaimsParams struct {
	Limit            int32           `json:"limit"`
	Offset           int32           `json:"offset"`
	SearchEmbedding  pgvector.Vector `json:"search_embedding"`
	AdjusterAssigned pgtype.Text     `json:"adjuster_assigned"`
	Status           pgtype.Text     `json:"status"`
	PolicyNumber     pgtype.Text     `json:"policy_number"`
	SortBy           string          `json:"sort_by"`
	SortDirection    string          `json:"sort_direction"`
}

type ListClaimsRow struct {
	ID                int64              `json:"id"`
	ItemType          ItemType           `json:"item_type"`
	ClaimID           pgtype.Text        `json:"claim_id"`
	PolicyNumber      pgtype.Text        `json:"policy_number"`
	SystemStatus      ItemStatus         `json:"system_status"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	PolicyholderID    string             `json:"policyholder_id"`
	ClaimType         string             `json:"claim_type"`
	DateOfLoss        pgtype.Date        `json:"date_of_loss"`
	DescriptionOfLoss string             `json:"description_of_loss"`
	ClaimAmount       pgtype.Numeric     `json:"claim_amount"`
	BusinessStatus    string             `json:"business_status"`
	AdjusterAssigned  string             `json:"adjuster_assigned"`
	SimilarityScore   interface{}        `json:"similarity_score"`
}

// backend/sql/apps/insurance/queries/insurance_queries.sql
// Fetches a paginated and filtered list of insurance claims.
func (q *Queries) ListClaims(ctx context.Context, arg ListClaimsParams) ([]ListClaimsRow, error) {
	rows, err := q.db.Query(ctx, listClaims,
		arg.Limit,
		arg.Offset,
		arg.SearchEmbedding,
		arg.AdjusterAssigned,
		arg.Status,
		arg.PolicyNumber,
		arg.SortBy,
		arg.SortDirection,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListClaimsRow
	for rows.Next() {
		var i ListClaimsRow
		if err := rows.Scan(
			&i.ID,
			&i.ItemType,
			&i.ClaimID,
			&i.PolicyNumber,
			&i.SystemStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PolicyholderID,
			&i.ClaimType,
			&i.DateOfLoss,
			&i.DescriptionOfLoss,
			&i.ClaimAmount,
			&i.BusinessStatus,
			&i.AdjusterAssigned,
			&i.SimilarityScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPolicyholders = `-- name: ListPolicyholders :many
SELECT id, item_type, policyholder_id, state, status, created_at, updated_at, policyholder_name, city, customer_since_date, customer_level, active_policies
FROM vw_policyholders
WHERE
    state = COALESCE($3, state)
AND
    customer_level = COALESCE($4, customer_level)
ORDER BY
    policyholder_name
LIMIT $1
OFFSET $2
`

type ListPolicyholdersParams struct {
	Limit         int32       `json:"limit"`
	Offset        int32       `json:"offset"`
	State         pgtype.Text `json:"state"`
	CustomerLevel pgtype.Text `json:"customer_level"`
}

// Fetches a paginated and filtered list of policyholders.
func (q *Queries) ListPolicyholders(ctx context.Context, arg ListPolicyholdersParams) ([]VwPolicyholder, error) {
	rows, err := q.db.Query(ctx, listPolicyholders,
		arg.Limit,
		arg.Offset,
		arg.State,
		arg.CustomerLevel,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VwPolicyholder
	for rows.Next() {
		var i VwPolicyholder
		if err := rows.Scan(
			&i.ID,
			&i.ItemType,
			&i.PolicyholderID,
			&i.State,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PolicyholderName,
			&i.City,
			&i.CustomerSinceDate,
			&i.CustomerLevel,
			&i.ActivePolicies,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchComments = `-- name: SearchComments :many
SELECT
    'Comment' AS source,
    comment::TEXT AS text,
    embedding <=> $1 AS similarity_score
FROM
    comments
WHERE
    embedding IS NOT NULL
ORDER BY
    similarity_score ASC
LIMIT $2
`

type SearchCommentsParams struct {
	Embedding pgvector.Vector `json:"embedding"`
	Limit     int32           `json:"limit"`
}

type SearchCommentsRow struct {
	Source          string      `json:"source"`
	Text            string      `json:"text"`
	SimilarityScore interface{} `json:"similarity_score"`
}

// Searches comments semantically.
func (q *Queries) SearchComments(ctx context.Context, arg SearchCommentsParams) ([]SearchCommentsRow, error) {
	rows, err := q.db.Query(ctx, searchComments, arg.Embedding, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchCommentsRow
	for rows.Next() {
		var i SearchCommentsRow
		if err := rows.Scan(&i.Source, &i.Text, &i.SimilarityScore); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchKnowledgeChunks = `-- name: SearchKnowledgeChunks :many
SELECT
    'Knowledge Chunk from ' || (custom_properties->'metadata'->>'document_name')::VARCHAR AS source,
    (custom_properties->>'chunk_text')::TEXT AS TEXT,
    embedding <=> $1 AS similarity_score
FROM
    items
WHERE
    item_type = 'KNOWLEDGE_CHUNK'
ORDER BY
    similarity_score ASC
LIMIT $2
`

type SearchKnowledgeChunksParams struct {
	Embedding pgvector.Vector `json:"embedding"`
	Limit     int32           `json:"limit"`
}

type SearchKnowledgeChunksRow struct {
	Source          interface{} `json:"source"`
	Text            string      `json:"text"`
	SimilarityScore interface{} `json:"similarity_score"`
}

// Searches semantically the knowledge base
func (q *Queries) SearchKnowledgeChunks(ctx context.Context, arg SearchKnowledgeChunksParams) ([]SearchKnowledgeChunksRow, error) {
	rows, err := q.db.Query(ctx, searchKnowledgeChunks, arg.Embedding, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchKnowledgeChunksRow
	for rows.Next() {
		var i SearchKnowledgeChunksRow
		if err := rows.Scan(&i.Source, &i.Text, &i.SimilarityScore); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
